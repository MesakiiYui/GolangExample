package main

import "fmt"

// 循环往往是性能上的热点。如果性能瓶颈出现在CPU上的话，那么九成可能性热点是在一个循环体内部。所以如果能让循环体并发执行，那么性能就会提高很多。

// 要并发循环很简单，只有在每个循环体内部启动协程。协程作为循环体可以并发执行。
// 调用启动前设置一个计数器，每一个循环体执行完毕就在计数器上加一个元素，调用完成后通过监听计数器等待循环协程全部完成。
func concurrent(){
	nums := []int{2, 3, 4}
	//建立计数器
	sem := make(chan int, 10)
	//FOR循环体
	for i, xi := range nums{
		//建立协程
		go func (i int, xi int) {
			fmt.Println(i,xi)
			//计数
			sem <- 0
		} (i, xi)
	}
	// 等待循环结束
	for i := 0; i < 10; i++ { <-sem }
}

// 上面是一个并发循环例子。通过计数器来等待循环全部完成。
// 如果结合上面提到的Future技术的话，则不必等待。可以等到真正需要的结果的地方，再去检查数据是否完成。

// 通过并发循环可以提供性能，利用多核，解决CPU热点。正因为协程可以大量创建，才能在循环体中如此使用，
// 如果是使用线程的话，就需要引入线程池之类的东西，防止创建过多线程，而协程则简单的多。
